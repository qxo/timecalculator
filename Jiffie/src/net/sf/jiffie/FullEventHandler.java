/*
 * file:       FullEventHandler.java
 * author:     Mark Richter
 * copyright:  (c) Packwood Software Limited 2004
 * date:       25/08/2004
 */

/*
 * This file is part of JIFFIE.
 *
 * JIFFIE is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * JIFFIE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JIFFIE; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

package net.sf.jiffie;

import com.jacob.com.Variant;


/**
 * This class implements an event handler which receives all of the events
 * generated by Internet Explorer. This class extends the new window event
 * handler, which only recieves new window events.
 * 
 * Note that the non-standard capitalisation of the method names is necessary 
 * to ensure that they match exactly the names used by Internet Explorer. 
 * 
 * Detailed documentation on these events can be found at:
 * 
 * http://msdn.microsoft.com/library/default.asp?url=/workshop/browser/webbrowser/reflist_vb.asp
 * 
 * The following events are no implemented, as per the Microsoft documentation:
 * 
 * BeforeNavigate    (Obsolete - use BeforeNavigate2)
 * NavigateComplete  (Obsolete - use NavigateComplete2)
 * UpdatePageStatus  (Not yet implemeneted by Internet Explorer)
 * WindowActivate    (Not yet implemeneted by Internet Explorer)
 * WindowMove        (Not yet implemeneted by Internet Explorer)
 * WindowResize      (Not yet implemeneted by Internet Explorer)
 */
public class FullEventHandler extends NewWindowEventHandler
{
   /**
    * Constructor.
    *
    * @param parentBrowser parent browser
    */
   public FullEventHandler (InternetExplorer parentBrowser)
   {
      super (parentBrowser);
   }
   
   /**
    * BeforeNavigate2 event handler.
    *
    * args[0] Object that evaluates to the top-level or frame
    *         WebBrowser object corresponding to the navigation.
    * args[1] String expression that evaluates to the URL to
    *         which the browser is navigating.
    * args[2] Flags
    * args[3] String expression that evaluates to the name of
    *         the frame in which the resource will be displayed,
    *         or Null if no named frame is targeted for the resource.
    * args[4] Data to send to the server if the HTTP POST transaction
    *         is being used.
    * args[5] Value that specifies the additional HTTP headers to send to the
    *         server (HTTP URLs only). The headers can specify such things as
    *         the action required of the server, the type of data being passed
    *         to the server, or a status code.
    * args[6] Boolean value that the container can set to True to cancel the
    *         navigation operation, or to False to allow it to proceed.
    *
    * @param args event arguments
    */
   public void BeforeNavigate2 (Variant[] args)
   {
      String url = args[1].toString();
      String targetFrameName;

      if (args[3].isNull())
      {
         targetFrameName = null;
      }
      else
      {
         targetFrameName = args[3].toString();
      }

      for (NavigationListener l : m_navigationListeners)
      {
         if (l.beforeNavigate(url, targetFrameName) == true)
         {
            args[6].putBoolean(true);
         }
      }
   }

   /**
    * ClientToHostWindow event handler
    * 
    * args[0]  Long integer that receives the width of the client window 
    *          and can be set by the host application. 
    * args[1]  Long integer that receives the height of the client window 
    *          and can be set by the host application.
    * 
    * @param args event arguments
    */
   public void ClientToHostWindow (Variant[] args)
   {
      int width = args[0].changeType(Variant.VariantInt).getInt();
      int height = args[1].changeType(Variant.VariantInt).getInt();
      
      for (WindowListener l : m_windowListeners)
      {
         l.clientToHostWindow(width, height);
      }
   }

   /**
    * CommandStateChange event handler.
    * 
    * args[0]  CommandStateChangeConstants enumeration value that specifies 
    *          the command that changed.
    * args[1]  Boolean value that specifies the enabled state.
    * 
    * @param args event arguments
    */
   public void CommandStateChange (Variant[] args)
   {
      int command = args[0].changeType(Variant.VariantInt).getInt();
      boolean enabled = args[1].changeType(Variant.VariantBoolean).getBoolean();
      
      for (WindowListener l : m_windowListeners)
      {
         l.commandStateChange(command, enabled);
      }      
   }

   /**
    * DocumentComplete event handler.
    *
    * args[0] Object that specifies the top-level or frame WebBrowser
    *         object corresponding to the event.
    * args[1] String that specifies the URL, Universal Naming Convention
    *         (UNC) file name, or pointer to an item identifier list (PIDL)
    *         of the loaded document.
    *
    * @param args event arguments
    */
   public void DocumentComplete (Variant[] args)
   {
      String url = args[1].toString();

      for (NavigationListener l : m_navigationListeners)
      {
         l.documentComplete(url);
      }
   }

   /**
    * DownloadBegin event handler.
    *
    * @param args event arguments
    */
   public void DownloadBegin (Variant[] args)
   {
      for (NavigationListener l : m_navigationListeners)
      {
         l.downloadBegin();
      }
   }

   /**
    * DownloadComplete event handler.
    *
    * @param args event arguments
    */
   public void DownloadComplete (Variant[] args)
   {
      for (NavigationListener l : m_navigationListeners)
      {
         l.downloadComplete();
      }
   }
   
   /**
    * FileDownload event handler
    * 
    * args[0]  Boolean that specifies whether the file is an Active Document.
    * args[1]  Boolean that specifies whether to continue the download 
    *          process and display the download dialog.
    * 
    * @param args event arguments
    */
   public void FileDownload (Variant[] args)
   {
      boolean active = args[0].changeType(Variant.VariantBoolean).getBoolean();
      
      for (NavigationListener l : m_navigationListeners)
      {
         if (l.fileDownload(active) == true)
         {
            args[1].putBoolean(true);
         }
      }
   }
   
   /**
    * NavigateComplete2 event handler
    *
    * args[0] Object that evaluates to the top-level or frame
    *         WebBrowser object corresponding to the navigation.
    * args[1] String that specifies the URL, Universal Naming Convention
    *         (UNC) file name, or pointer to an item identifier list (PIDL)
    *         of the loaded document.
    *
    * @param args event arguments
    */
   public void Navigate2Complete (Variant[] args)
   {
      String url = args[1].toString();

      for (NavigationListener l : m_navigationListeners)
      {
         l.navigateComplete(url);
      }
   }

   /**
    * NavigateError event handler.
    *
    * args[0] Object that evaluates to the top-level or frame
    *         WebBrowser object corresponding to the navigation.
    * args[1] URL
    * args[2] Target frame name
    * args[3] Status code
    * args[4] Cancel navigation flag
    * 
    * @param args event arguments
    */
   public void NavigateError (Variant[] args)
   {
      String url = args[1].toString();
      String targetFrameName;

      if (args[2].isNull() == true)
      {
         targetFrameName = null;
      }
      else
      {
         targetFrameName = args[2].toString();
      }

      int statusCode = args[3].changeType(Variant.VariantInt).getInt();

      for (NavigationListener l : m_navigationListeners)
      {
         if (l.navigateError(url, targetFrameName, statusCode) == true)
         {
            args[4].putBoolean(true);
         }
      }
   }
   
   /**
    * OnFullScreen event handler
    * 
    * args[0]  Boolean value that specifies whether the browser 
    *          window is in full-screen mode.
    * 
    * @param args event arguments
    */
   public void OnFullScreen (Variant[] args)
   {
      boolean fullScreen = args[0].changeType(Variant.VariantBoolean).getBoolean();
      for (WindowListener l : m_windowListeners)
      {
         l.onFullScreen(fullScreen);
      }            
   }

   /**
    * OnMenuBar event handler.
    * 
    * args[0]  Boolean value that specifies whether the menu bar is shown
    * 
    * @param args event arguments
    */
   public void OnMenuBar (Variant[] args)
   {
      boolean menuBarVisible = args[0].changeType(Variant.VariantBoolean).getBoolean();
      for (WindowListener l : m_windowListeners)
      {
         l.onMenuBar(menuBarVisible);
      }            
   }
   
   /**
    * OnQuit event handler.
    *
    * @param args event arguments
    */
   public void OnQuit (Variant[] args)
   {
      for (WindowListener l : m_windowListeners)
      {
         l.onQuit();
      }
   }

   /**
    * OnStatusBar event handler.
    * 
    * args[0]  Boolean value that specifies whether the status bar is shown.
    * 
    * @param args event arguments
    */
   public void OnStatusBar (Variant[] args)
   {
      boolean statusBarVisible = args[0].changeType(Variant.VariantBoolean).getBoolean();
      for (WindowListener l : m_windowListeners)
      {
         l.onStatusBar(statusBarVisible);
      }            
   }

   /**
    * OnTheatreMode event handler
    * 
    * args[0]  Boolean value that specifies whether the browser is in 
    *          theatre mode.
    * 
    * @param args event arguments
    */
   public void OnTheatreMode (Variant[] args)
   {
      boolean theatreMode = args[0].changeType(Variant.VariantBoolean).getBoolean();
      for (WindowListener l : m_windowListeners)
      {
         l.onTheatreMode(theatreMode);
      }            
   }

   /**
    * OnToolBar event handler.
    * 
    * args[0]  Boolean value that specifies whether the toolbar is shown.
    * 
    * @param args event arguments
    */
   public void OnToolBar (Variant[] args)
   {
      boolean toolBarVisible = args[0].changeType(Variant.VariantBoolean).getBoolean();
      for (WindowListener l : m_windowListeners)
      {
         l.onToolBar(toolBarVisible);
      }            
   }

   /**
    * OnVisible event handler.
    * 
    * args[0]  Boolean that specifies whether the object is visible.
    * 
    * @param args event arguments
    */
   public void OnVisible (Variant[] args)
   {
      boolean visible = args[0].changeType(Variant.VariantBoolean).getBoolean();
      for (WindowListener l : m_windowListeners)
      {
         l.onVisible(visible);
      }            
   }

   /**
    * PrintTemplateInstantiation event handler.
    * 
    * args[0]  Object that evaluates to the top-level or frame WebBrowser 
    *          object corresponding to the navigation.
    * 
    * @param args event arguments
    */
   public void PrintTemplateInstantiation (Variant[] args)
   {
      for (WindowListener l : m_windowListeners)
      {
         l.printTemplateInstantiation();
      }            
   }

   /**
    * PrintTemplateTeardown event handler.
    * 
    * args[0]  Object that evaluates to the top-level or frame WebBrowser 
    *          object corresponding to the navigation.
    *
    * @param args event arguments
    */
   public void PrintTemplateTeardown (Variant[] args)
   {
      for (WindowListener l : m_windowListeners)
      {
         l.printTemplateTeardown();
      }            
   }

   /**
    * PrivacyImpactedStateChange event handler.
    * 
    * args[0]  Boolean that indicates whether the current top-level 
    *          URL has violated the browser's privacy settings.
    * 
    * @param args event arguments
    */
   public void PrivacyImpactedStateChange (Variant[] args)
   {
      boolean impacted = args[0].changeType(Variant.VariantBoolean).getBoolean();
      for (WindowListener l : m_windowListeners)
      {
         l.privacyImpactedStateChange(impacted);
      }            
   }
       
   /**
    * ProgressChange event handler.
    *
    * args[0] Long that specifies the amount of total progress
    *         to show, or -1 when progress is complete.
    * args[1] Long that specifies the maximum progress value.
    *
    * @param args event arguments
    */
   public void ProgressChange (Variant[] args)
   {
      int nProgress = args[0].changeType(Variant.VariantInt).getInt();
      int nProgressMax = args[1].changeType(Variant.VariantInt).getInt();

      for (NavigationListener l : m_navigationListeners)
      {
         l.progressChange(nProgress, nProgressMax);
      }
   }

   /**
    * PropertyChange event handler.
    * 
    * args[0]  String that specifies the name of the property 
    *          whose value has changed. 
    *
    * @param args event arguments
    */
   public void PropertyChange (Variant[] args)
   {
      String property = args[0].toString();
      for (WindowListener l : m_windowListeners)
      {
         l.propertyChange(property);
      }                  
   }

   /**
    * SetSecureLockIcon event handler.
    * 
    * args[0]  Integer that specifies one of the SecureLockIconConstants.
    * 
    * @param args event arguments
    */
   public void SetSecureLockIcon (Variant[] args)
   {
      int flag = args[0].changeType(Variant.VariantInt).getInt();
      for (WindowListener l: m_windowListeners)
      {
         l.setSecureLockIcon(flag);
      }                        
   }
      
   /**
    * StatusTextChange event handler.
    *
    * args[0] String that specifies the new status bar text.
    *
    * @param args event arguments
    */
   public void StatusTextChange (Variant[] args)
   {
      String sText = args[0].toString();

      for (WindowListener l : m_windowListeners)
      {
         l.statusTextChange(sText);
      }
   }
   
   /**
    * TitleChange event handler.
    *
    * args[0] String that specifies the new document title.
    *
    * @param args event arguments
    */
   public void TitleChange (Variant[] args)
   {
      String sText = args[0].toString();

      for (WindowListener l: m_windowListeners)
      {
         l.titleChange(sText);
      }
   }
   
   /**
    * WindowClosing event handler.
    *
    * args[0] Boolean that specifies whether the window was
    *         created from script.
    * args[1] Boolean value that specifies whether the window
    *         is prevented from closing.
    *
    * @param args event arguments
    */
   public void WindowClosing (Variant[] args)
   {
      boolean isChild = args[0].changeType(Variant.VariantBoolean).getBoolean();
      for (WindowListener l : m_windowListeners)
      {
         if (l.windowClosing(isChild) == true)
         {
            args[1].putBoolean(true);
         }
      }
   }

   /**
    * WindowSetHeight event handler.
    * 
    * args[0]  Long that specifies the new height of the WebBrowser control. 
    * 
    * @param args event arguments
    */
   public void WindowSetHeight (Variant[] args)
   {
      int height = args[0].changeType(Variant.VariantInt).getInt();
      for (WindowListener l : m_windowListeners)
      {
         l.windowSetHeight(height);
      }      
   }

   /**
    * WindowSetLeft event handler.
    * 
    * args[0]  Long that specifies the new left position of the 
    *          WebBrowser window
    * 
    * @param args event arguments
    */
   public void WindowSetLeft (Variant[] args)
   {
      int left = args[0].changeType(Variant.VariantInt).getInt();
      for (WindowListener l : m_windowListeners)
      {
         l.windowSetLeft(left);
      }      
   }

   /**
    * WindowSetResizable event handler.
    * 
    * args[0]  Boolean that specifies whether the WebBrowser 
    *          control is resizable.
    * 
    * @param args event arguments
    */
   public void WindowSetResizable (Variant[] args)
   {
      boolean resizable = args[0].changeType(Variant.VariantBoolean).getBoolean();
      for (WindowListener l : m_windowListeners)
      {
         l.windowSetResizable(resizable);
      }            
   }

   /**
    * WindowSetTop event handler.
    * 
    * args[0]  Long that specifies the top position of the WebBrowser control.
    * 
    * @param args event arguments
    */
   public void WindowSetTop (Variant[] args)
   {
      int top = args[0].changeType(Variant.VariantInt).getInt();
      for (WindowListener l : m_windowListeners)
      {
         l.windowSetTop(top);
      }            
   }

   /**
    * WindowSetWidth event handler.
    * 
    * args[0]  Long that specifies the width of the WebBrowser control.
    * 
    * @param args event arguments
    */
   public void WindowSetWidth (Variant[] args)
   {
      int width = args[0].changeType(Variant.VariantInt).getInt();
      for (WindowListener l : m_windowListeners)
      {
         l.windowSetWidth(width);
      }            
   }           
}
